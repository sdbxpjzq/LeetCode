
https://mp.weixin.qq.com/s/6yq3gNkqxKp2exlKUy4Kvw

## 思路1  暴力法
索引从字符串的第一位开始，将后面的字符依次加入到 set 里面。  
如果 set 里面已经有了该字符，此次循环结束，内循环结束后记录 size。  
字符串的每一位都用这种方法去计算，得到的最大的 size 即是答案。

时间复杂度：O(n^2)
空间复杂度：O(m) ，m 为无重复字符的最长子串的长度。

## 思路2
我们设置两根指针（i 和 j ）与一个集合set。两个指针之间是一个范围，我们要维护这个范围内不能出现重复的字符。  
而这个 set 就是是用来判断范围内是否有重复的字符。具体做法如下：i 和 j 开始的时候都指向 字符串首。然后执行下面两个步骤。

如果 j 指针所指元素未在 set 里面，我们将其 add 进 set 。继续后移 j 。
如果 j 指针所指元素在 set 里面，我们将 i 指针所指元素从 set 中移除，继续后移 i 。i 会一直往后移，直到 j 的元素不在 set 里面。


## 思路3 -- 最优解
思路2 中，我们在遇到重复的字符时，不断在移动 i 指针。这个地方其实可以优化，让 i 指针直接跳到重复元素的下一个位置。
让 i 指针直接跳到重复元素的下一个位置。那我们就需要保存每个元素以及它的位置。  
一个 Value, 一个 Index 。自然会想到 HashMap



1.用一个mapper记录出现过并且没有被删除的字符  
2.用一个滑动窗口记录当前index开始的最大的不重复的字符序列  
3.用res去记录目前位置最大的长度，每次滑动窗口更新就去决定是否需要更新res