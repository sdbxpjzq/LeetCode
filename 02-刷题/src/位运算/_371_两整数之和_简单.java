package 位运算;

/**
 * 371. 两整数之和
 * 不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。
 *
 *
 * <p>
 * 思路：
 * 用位运算实现加法也就是计算机用二进制进行运算，32位的CPU只能表示32位内的数，这里先用1位数的加法来进行，在不考虑进位的基础上，如下
 * 1 + 1 = 0
 * 1 + 0 = 1
 * 0 + 1 = 1
 * 0 + 0 = 0
 * <p>
 * 很明显这几个表达式可以用位运算的“^”来代替，如下
 * 1 ^ 1 = 0
 * 1 ^ 0 = 1
 * 0 ^ 1 = 1
 * 0 ^ 0 = 0
 * <p>
 * 这样我们就完成了简单的一位数加法，那么要进行二位的加法，这个方法可行不可行呢？肯定是不行的，矛盾就在于，如何去获取进位？要获取进位我们可以如下思考：
 * 0 + 0 = 0
 * 1 + 0 = 0
 * 0 + 1 = 0
 * 1 + 1 = 1
 * //换个角度看就是这样
 * 0 & 0 = 不进位
 * 1 & 0 = 不进位
 * 0 & 1 = 不进位
 * 1 & 1 = 进位
 * <p>
 * 正好，在位运算中，我们用“<<”表示向左移动一位，也就是“进位”。那么我们就可以得到如下的表达式
 * //进位可以用如下表示：
 * (x&y)<<1
 * <p>
 * 到这里，我们基本上拥有了这样两个表达式
 * x^y //执行加法
 * (x&y)<<1 //进位操作
 * <p>
 * 现总结如下：
 * 定理1：
 * 设a，b为两个二进制数，则a+b = a^b + (a&b)<<1。证明：a^b是不考虑进位时加法结果。当二进制位同时为1时，才有进位，
 * 因此 (a&b)<<1是进位产生的值，称为进位补偿。将两者相加便是完整加法结果。
 * 定理2：
 * 使用定理1可以实现只用位运算进行加法运算。证明：利用定理1中的等式不停对自身进行迭代。每迭代一次，进位补偿右边就多一位0，
 * 因此最多需要加数二进制位长度次迭代，进位补偿就变为0，这时运算结束。
 */
public class _371_两整数之和_简单 {

    public static void main(String[] args) {
        int sum = getSum(1, 2);
        System.out.println(sum);
    }

    public static int getSum(int a, int b) {
        int sum, carry;
        sum = a ^ b;
        // carry = ((ununsigned int)a&b)<<1;
        carry = ((int) a & b) << 1; // 是否进位
        if (carry != 0) {
            return getSum(sum, carry);
        }
        return sum;
    }
}
